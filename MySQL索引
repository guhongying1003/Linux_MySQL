### 索引

用来加快数据的访问

提高IO效率 : 次数 / 量

```markdown
1.MySQL数据存储在什么地方?
    磁盘

2.查询数据比较慢, 一般情况下卡在哪里?
    IO

3.去磁盘读取数据时,是用多少读多少吗?
	磁盘预读
4.所有存储在哪里
	磁盘, 查询数据的时候回优先将索引加载到内存中
5.索引在存储的时候需要什么信息?需要存储什么字段?
	唯一标识(key) key:实际数据行中存储的值
	文件地址
	offset: 偏移量
6.这种格式的数据要使用什么样的数据结构来进行存储?
	K-V
	哈希表,数(二叉树,红黑树,AVL数,B树,B+树)
7.MySQL的索引系统中不是按照刚刚说的格式存储的,为什么?	
	哈希表: 1.哈希冲突会造成数据散列不均匀,产生大量的线性查询,比较浪费时间.
		   2.不支持范围查询
		   3.对于内存空间的要求比较高
		   ------
		   等值查询非常快, memory存储引擎使用的是hash索引,InnoDB支持自适应hash
	树:
		二叉树 : 无序
		BST : Binary Search Tree 有序二叉树, 二分查找可以提高查询效率, 但是有可能变链表
		AVL : (平衡二叉树)通过左旋或右旋让树平衡,最短子树和最长子树高度差不超过1
			  通过插入性能的损失来弥补查询性能的提升,适合读多写少.
		红黑树 : 通过左旋或右旋让树平衡,还有变色的行为.
			    最短子树和最长子树高度不超过两倍
			    随着数据量变大,数深越大,IO次数越多,影响读取的效率
			    
		B树 : 数据与索引字段绑定, 能存的数据少
		B+树 : 叶子节点存数据
			   查找数据方式: 主键的范围查找和分页查找, 另一种是从根节点开始,进行随机查找.
8.聚簇索引
	是否是聚簇索引取决于数据跟索引是否放在一起的
	innodb 只能有一个聚簇索引 
	向innodb插入数据的时候,必须要包含一个索引的key值
	这个key值,可以是主键,如果没有主键,那么就是唯一键,如果没有唯一键,那么就是自生成的6字节的rowid
	MySQL中rowid不可见
```

补充:

```markdown
1.局部性原理
	数据和程序都有聚集成群的倾向, 同时之前按被访问过的数据很可能再次被查询,空间局部性,时间局部性.
2.磁盘预读
	内存跟磁盘在发生数据交互的时候,一般情况下有一个最小的逻辑单元,称之为页,datapage,页一般有操作系统决定,一般是4K或8K, 而我们在进行数据交互的时候,可以取页的整数倍来进行读取,InnoDB存储引擎每次读取数据,16K.
3.OLAP与OLTP
	OLAP -> 联机分析处理 -> 对海量历史数据进行分析,产生决策性的影响 -> 数据仓库 -> Hive
	OLTP -> 联机事务处理 -> 要求在很短的时效内返回对应的结果 -> 关系型数据库 -> mysql,oracle...
    
```



```markdown
回表
	create table (id,name,age) primary key(id),index(name);
	select * from table where name = 'zs';
	先根据name查询id,再根据id查询整行的记录
	走了2颗B+树,此时这种现象叫做回表
	当根据普通索引查询到聚簇索引的key值之后,再根据key值再到聚簇索引获取记录
索引覆盖
	select id,name from table where name = 'zs';
	根据name可以直接查询到id,name两个列的值,直接返回即可,不需要从聚簇索引查询任何数据,此时叫做索引覆盖.
最左匹配
	联合索引
	index(name,age)
	select * from table where name = ? and age = ?; -- 走索引
	select * from table where age = ? and name = ?; -- 走索引,MySQL优化器会调整对应顺序
	select * from table where name = ?; -- 走索引
	select * from table where age = ?;  -- 不走索引
索引下推
	select * from table where name = ? and age = ?;
	
	client
	  |
	  |
    service
      |
      |
    存储引擎 
	
	在没有索引下推之前,先根据name从存储引擎中获取符合规则的数据,然后再server层对age进行过滤.
    有索引下推之后, 根据name ,age两个条件来从存储引擎中获取对应的数据.
    
```

### MySQL调优

#### 性能监控

```
1. show profile
	使用show profile查询剖析工具,可以指定具体type
2. performance schema
	使用performance schema来更加容易的监控mysql
3. show processlist
	使用show processlist查看连接的线程个数,来观察是否大量线程处于不正常状态或者其他不正常特性
```

#### schema与数据类型优化

```markdown
数据类型
	更小的通常更好
	简单就好

合理使用范式和反范式
	优点: 范式化的更新通常比反范式要快
		 当数据较好的范式化后,很少或者没有重复的数据
		 范式化的数据比较小,可以放在内存中,操作比较快
	缺点: 通常需要进行关联	 
反范式
	优点: 所有的数据都在同一张表中,可以避免关联
	     可以设计有效的索引
	缺点: 表格内的冗余较多,删除数据时候会造成表有些有用的信息丢失

主键的选择
	代理主键	与业务无关的,无意义的数字序列
	自然主键	事务属性中的自然唯一标识
	推荐使用代理主键 它们不与业务耦合,因此更容易维护
		一个大多数,最好是全部表,通用的键策略能够减少需要编写源码数量,减少系统的总体拥有成本

字符集的选择
	1. 纯拉丁文能表示的内容,没必要选择Latin1之外的其他字符编码,因为这会节省大量的存储空间.
	2. 如果我们可以确定不需要存放多种语言,就没必要非得使用UTF8或者UNICODE字符类型,这会造成大量的存储空间浪费
	3. MySQL的数据类型可以精确到字段,所以当我们需要大型数据库中存放多字节数据的时候,可以通过对不同表不同字段使用不同的数据类型来较大减小数据存储量,进而降低IO操作次数并提高缓存命中率.

存储引擎的选择
	MyISAM 适合select
	InnoDB 适合update insert delete

适当的数据冗余

适当的拆分
	当我们的表中存在类似TEXT或者是很大的VARCHAR类型时候,如果我们大部分访问这张表的时候都不需要这个字段,我们就该义无反顾的将其拆分到另外的独立表中,以减少常用的数据所占用的存储空间,这样做的一个明显好处是每个数据块中可以存储的数据条数可以大大增加,叫减少物理IO,也能大大提高内存中的缓存命中率.
```

#### 执行计划

```markdown
id: select查询的序列号,包含一组数字,表示查询中执行select子句或者操作表的顺序.
id好分为三种情况:
	1. 如果id相同,那么执行顺序从上到下
	2. 如果id不同,如果是子查询,id的序号会递增,id值越大优先级越高,越先被执行
	3. id相同和不同的,同事存在:相同的可以认为是一组,从上往下顺序执行,在所有组中,id值越大,优先级越高,越先执行.
	
select_type: 主要用来分辨查询的类型,是普通查询还是联合查询还是子查询	

table: 对应正在访问哪一个表,表名或者别名,可能是临时表或者union合并结果集
	1. 如果是具体表名,则表明从实际的物理表中获取数据,当然也可以是表的别名
	2. 表名的derivedN的形式,表示使用了id为N的查询产生衍生表
	3. 当有union result的时候,表名是union n1,n2表示参与union的id
```



#### 索引优化







